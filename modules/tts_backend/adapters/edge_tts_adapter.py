"""
# ----------------------------------------------------------------------------
# Edge TTSÈÄÇÈÖçÂô®
# 
# ÂÆûÁé∞Microsoft Edge TTSÊúçÂä°ÁöÑÈÄÇÈÖçÂô®
# ÊîØÊåÅÂ§öÁßçËØ≠Ë®ÄÂíåÂ£∞Èü≥ÔºåÂÖçË¥π‰ΩøÁî®ÔºåÊòØTTSÊúçÂä°ÁöÑÈ¶ñÈÄâ
# ‰ΩøÁî®edge-ttsÂ∫ìËøõË°åÂÆûÁé∞
# ----------------------------------------------------------------------------
"""

import os
import sys
import time
import asyncio
import tempfile
import warnings
import concurrent.futures
import threading
from typing import Dict, List, Optional, Any
from pathlib import Path

from ..base import TTSEngineAdapter, TTSResult, AudioSegment
from ..utils import validate_audio_output, generate_unique_filename


def run_async_safely(coro):
    """
    # ----------------------------------------------------------------------------
    # ÂÆâÂÖ®ËøêË°åÂºÇÊ≠•ÂáΩÊï∞ÁöÑËæÖÂä©ÂáΩÊï∞
    # 
    # Â§ÑÁêÜ‰∫ã‰ª∂Âæ™ÁéØÂ∑≤Â≠òÂú®ÁöÑÊÉÖÂÜµÔºåÈÅøÂÖç"RuntimeError: This event loop is already running"
    # ÁâπÂà´‰ºòÂåñWindowsÁ≥ªÁªüÁöÑProactorEventLoopÈóÆÈ¢ò
    # ----------------------------------------------------------------------------
    """
    try:
        # Â∞ùËØïËé∑ÂèñÂΩìÂâçËøêË°åÁöÑ‰∫ã‰ª∂Âæ™ÁéØ
        loop = asyncio.get_running_loop()
        # Â¶ÇÊûúÂ∑≤ÊúâÂæ™ÁéØËøêË°åÔºåÂú®Êñ∞Á∫øÁ®ã‰∏≠ÂàõÂª∫Êñ∞‰∫ã‰ª∂Âæ™ÁéØ
        def run_in_thread():
            # ËÆæÁΩÆ‰∫ã‰ª∂Âæ™ÁéØÁ≠ñÁï•ÔºåÈÅøÂÖçWindows‰∏äÁöÑProactorEventLoopÈóÆÈ¢ò
            if sys.platform == 'win32':
                # Âú®Windows‰∏ä‰ΩøÁî®SelectorEventLoopËÄå‰∏çÊòØProactorEventLoop
                asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
            
            new_loop = asyncio.new_event_loop()
            asyncio.set_event_loop(new_loop)
            try:
                # ÂøΩÁï•Ë≠¶ÂëäÔºåÈÅøÂÖçProactorBasePipeTransportÁöÑdelË≠¶Âëä
                with warnings.catch_warnings():
                    warnings.simplefilter("ignore", ResourceWarning)
                    warnings.simplefilter("ignore", RuntimeWarning)
                    result = new_loop.run_until_complete(coro)
                return result
            finally:
                # Á°Æ‰øùÊ≠£Á°ÆÊ∏ÖÁêÜ‰∫ã‰ª∂Âæ™ÁéØ
                try:
                    # Á≠âÂæÖÊâÄÊúâ‰ªªÂä°ÂÆåÊàê
                    pending = asyncio.all_tasks(new_loop)
                    if pending:
                        new_loop.run_until_complete(asyncio.gather(*pending, return_exceptions=True))
                except Exception:
                    pass
                finally:
                    new_loop.close()
                    # Âú®Windows‰∏äÈáçÁΩÆ‰∫ã‰ª∂Âæ™ÁéØ
                    if sys.platform == 'win32':
                        asyncio.set_event_loop(None)
                
        with concurrent.futures.ThreadPoolExecutor() as executor:
            future = executor.submit(run_in_thread)
            return future.result()
            
    except RuntimeError:
        # Ê≤°ÊúâËøêË°åÁöÑ‰∫ã‰ª∂Âæ™ÁéØÔºåÁõ¥Êé•‰ΩøÁî®asyncio.run
        # ‰ΩÜÂú®Windows‰∏ä‰πüÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜ
        if sys.platform == 'win32':
            # ‰ΩøÁî®SelectorEventLoop
            old_policy = asyncio.get_event_loop_policy()
            try:
                asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
                with warnings.catch_warnings():
                    warnings.simplefilter("ignore", ResourceWarning)
                    warnings.simplefilter("ignore", RuntimeWarning)
                    return asyncio.run(coro)
            finally:
                asyncio.set_event_loop_policy(old_policy)
        else:
            return asyncio.run(coro)


class EdgeTTSAdapter(TTSEngineAdapter):
    """Edge TTSÈÄÇÈÖçÂô®"""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """ÂàùÂßãÂåñEdge TTSÈÄÇÈÖçÂô®"""
        super().__init__(config)
        self.version = "1.0.0"
        
        # Edge TTSÁâπÂÆöÈÖçÁΩÆ
        self.voice = self.config.get('voice', 'zh-CN-XiaoxiaoNeural')
        self.rate = self.config.get('rate', '+0%')
        self.pitch = self.config.get('pitch', '+0Hz')
        self.volume = self.config.get('volume', '+0%')
        
        # ÊîØÊåÅÁöÑÂ£∞Èü≥ÂàóË°®
        self.supported_voices = [
            "zh-CN-XiaoxiaoNeural", "zh-CN-YunxiNeural", "zh-CN-YunjianNeural",
            "zh-CN-XiaoyiNeural", "zh-CN-YunyangNeural", "zh-CN-XiaochenNeural",
            "en-US-AriaNeural", "en-US-JennyNeural", "en-US-GuyNeural",
            "en-US-GuyNeural", "en-US-RyanMultilingualNeural"
        ]
    
    def initialize(self) -> None:
        """ÂàùÂßãÂåñEdge TTSÂºïÊìé"""
        try:
            import edge_tts
            self.edge_tts = edge_tts
            self._is_initialized = True
            print(f"‚úÖ Edge TTSÂºïÊìéÂàùÂßãÂåñÊàêÂäü")
        except ImportError:
            raise RuntimeError("‚ùå Áº∫Â∞ëedge-ttsÂ∫ìÔºåËØ∑ÂÆâË£Ö: pip install edge-tts")
    
    def configure(self, config: Dict[str, Any]) -> None:
        """ÈÖçÁΩÆEdge TTSÂèÇÊï∞"""
        self.voice = config.get('voice', self.voice)
        self.rate = config.get('rate', self.rate)
        self.pitch = config.get('pitch', self.pitch)
        self.volume = config.get('volume', self.volume)
        
        # È™åËØÅÂ£∞Èü≥ÊòØÂê¶ÊîØÊåÅ
        if self.voice not in self.supported_voices:
            print(f"‚ö†Ô∏è  ‰∏çÊîØÊåÅÁöÑÂ£∞Èü≥: {self.voice}Ôºå‰ΩøÁî®ÈªòËÆ§Â£∞Èü≥")
            self.voice = 'zh-CN-XiaoxiaoNeural'
        
        self._is_configured = True
        print(f"üîß Edge TTSÈÖçÁΩÆÂÆåÊàê: voice={self.voice}")
    
    def synthesize(self, text: str, 
                  output_path: Optional[str] = None,
                  **kwargs) -> TTSResult:
        """ÂêàÊàêÂçï‰∏™ÊñáÊú¨ÁâáÊÆµ"""
        if not self._is_initialized:
            self.initialize()
        
        if not self._is_configured:
            self.configure(self.config)
        
        # È™åËØÅÊñáÊú¨
        if not self.validate_text(text):
            raise ValueError(f"‚ùå Êó†ÊïàÊñáÊú¨: {text}")
        
        # ÁîüÊàêËæìÂá∫Ë∑ØÂæÑ
        if output_path is None:
            output_path = generate_unique_filename(text, "edge_tts")
        
        self._log_synthesis_start(text)
        start_time = time.time()
        
        try:
            # ÂºÇÊ≠•Ë∞ÉÁî®Edge TTS - ‰ΩøÁî®ÂÆâÂÖ®ÁöÑÂºÇÊ≠•ËøêË°åÂáΩÊï∞
            audio_path = run_async_safely(self._synthesize_async(text, output_path))
            
            # È™åËØÅËæìÂá∫
            if not validate_audio_output(audio_path):
                raise RuntimeError(f"‚ùå Èü≥È¢ëÂêàÊàêÂ§±Ë¥•: {audio_path}")
            
            # Ëé∑ÂèñÈü≥È¢ëÊó∂Èïø
            duration = self._get_audio_duration_simple(audio_path)
            
            # ÂàõÂª∫ÁªìÊûú
            segment = AudioSegment(
                text=text,
                audio_path=audio_path,
                duration=duration,
                voice=self.voice,
                language=self._detect_language(text),
                metadata={
                    'engine': 'edge_tts',
                    'voice': self.voice,
                    'rate': self.rate,
                    'pitch': self.pitch,
                    'volume': self.volume
                }
            )
            
            result = TTSResult(
                segments=[segment],
                total_duration=duration,
                output_path=audio_path,
                metadata={'engine': 'edge_tts', 'voice': self.voice}
            )
            
            elapsed_time = time.time() - start_time
            self._log_synthesis_complete(elapsed_time, audio_path)
            
            return result
            
        except Exception as e:
            print(f"‚ùå Edge TTSÂêàÊàêÂ§±Ë¥•: {e}")
            raise
    
    async def _synthesize_async(self, text: str, output_path: str) -> str:
        """ÂºÇÊ≠•ÂêàÊàêÈü≥È¢ë"""
        # ÂàõÂª∫Edge TTSÈÄö‰ø°ÂØπË±°
        communicate = self.edge_tts.Communicate(text, self.voice)
        
        # ‰øùÂ≠òÈü≥È¢ë
        await communicate.save(output_path)
        
        return output_path

    def synthesize_batch(self, 
                        texts: List[str],
                        output_dir: Optional[str] = None,
                        **kwargs) -> TTSResult:
        """ÊâπÈáèÂêàÊàêÂ§ö‰∏™ÊñáÊú¨ÁâáÊÆµ"""
        if output_dir is None:
            output_dir = "output/audio"
        
        os.makedirs(output_dir, exist_ok=True)
        
        segments = []
        total_duration = 0.0
        
        print(f"üéµ ÂºÄÂßãEdge TTSÊâπÈáèÂêàÊàê: {len(texts)}‰∏™ÊñáÊú¨ÁâáÊÆµ")
        
        for i, text in enumerate(texts):
            try:
                # ÁîüÊàêËæìÂá∫Ë∑ØÂæÑ
                output_path = os.path.join(output_dir, f"edge_tts_batch_{i+1:03d}.wav")
                
                # ÂêàÊàêÂçï‰∏™ÁâáÊÆµ
                result = self.synthesize(text, output_path)
                
                if result.segments:
                    segment = result.segments[0]
                    segment.start_time = total_duration
                    segment.end_time = total_duration + (segment.duration or 0)
                    segments.append(segment)
                    total_duration += (segment.duration or 0)
                
                print(f"‚úÖ ÊâπÈáèÂêàÊàêËøõÂ∫¶: {i+1}/{len(texts)}")
                
            except Exception as e:
                print(f"‚ùå ÊâπÈáèÂêàÊàêÂ§±Ë¥• ({i+1}/{len(texts)}): {e}")
                continue
        
        # ÂêàÂπ∂Èü≥È¢ëÊñá‰ª∂ÔºàÂèØÈÄâÔºâ
        if len(segments) > 1:
            merged_path = os.path.join(output_dir, "edge_tts_merged.wav")
            audio_paths = [seg.audio_path for seg in segments]
            try:
                from ..utils import TTSProcessor
                processor = TTSProcessor()
                merged_path = processor.merge_audio_files(audio_paths, merged_path)
                output_path = merged_path
            except Exception as e:
                print(f"‚ö†Ô∏è  Èü≥È¢ëÂêàÂπ∂Â§±Ë¥•: {e}")
                output_path = None
        else:
            output_path = segments[0].audio_path if segments else None
        
        result = TTSResult(
            segments=segments,
            total_duration=total_duration,
            output_path=output_path,
            metadata={'engine': 'edge_tts', 'batch_size': len(texts)}
        )
        
        print(f"‚úÖ Edge TTSÊâπÈáèÂêàÊàêÂÆåÊàê: {len(segments)}/{len(texts)} ÊàêÂäü")
        return result
    
    def get_supported_voices(self) -> List[str]:
        """Ëé∑ÂèñÊîØÊåÅÁöÑÂ£∞Èü≥ÂàóË°®"""
        return self.supported_voices.copy()
    
    def get_supported_languages(self) -> List[str]:
        """Ëé∑ÂèñÊîØÊåÅÁöÑËØ≠Ë®ÄÂàóË°®"""
        return ['zh-CN', 'zh-TW', 'en-US', 'en-GB', 'ja-JP', 'ko-KR']
    
    def _detect_language(self, text: str) -> str:
        """Ê£ÄÊµãÊñáÊú¨ËØ≠Ë®Ä"""
        # ÁÆÄÂçïÁöÑËØ≠Ë®ÄÊ£ÄÊµã
        if any('\u4e00' <= char <= '\u9fff' for char in text):
            return 'zh-CN'
        elif any('\u3040' <= char <= '\u309f' or '\u30a0' <= char <= '\u30ff' for char in text):
            return 'ja-JP'
        elif any('\uac00' <= char <= '\ud7af' for char in text):
            return 'ko-KR'
        else:
            return 'en-US'
    
    def _get_audio_duration_simple(self, audio_path: str) -> float:
        """ÁÆÄÂçïËé∑ÂèñÈü≥È¢ëÊó∂Èïø"""
        try:
            from ..utils import TTSProcessor
            processor = TTSProcessor()
            return processor.get_audio_duration(audio_path)
        except Exception:
            # Â¶ÇÊûúÊó†Ê≥ïËé∑ÂèñÁ≤æÁ°ÆÊó∂ÈïøÔºå‰ΩøÁî®‰º∞ÁÆó
            with open(audio_path, 'rb') as f:
                # Á≤óÁï•‰º∞ÁÆóÔºöWAVÊñá‰ª∂Â§ßÂ∞èÈô§‰ª•Âπ≥ÂùáÊØîÁâπÁéá
                file_size = len(f.read())
                estimated_duration = file_size / (44100 * 2 * 2)  # 44.1kHz, 16bit, stereo
                return max(estimated_duration, 0.5)
    
    def cleanup(self) -> None:
        """Ê∏ÖÁêÜËµÑÊ∫ê"""
        super().cleanup()
        print(f"üßπ Edge TTSÈÄÇÈÖçÂô®Â∑≤Ê∏ÖÁêÜ")


# ‰æøÊç∑ÂáΩÊï∞Ôºå‰øùÊåÅ‰∏éÂéüÊúâ‰ª£Á†ÅÁöÑÂÖºÂÆπÊÄß
def edge_tts(text: str, 
            output_path: Optional[str] = None,
            voice: str = "zh-CN-XiaoxiaoNeural") -> str:
    """
    Edge TTS‰æøÊç∑ÂáΩÊï∞ÔºàÂÖºÂÆπÂéüÊúâÊé•Âè£Ôºâ
    
    Args:
        text: Ë¶ÅÂêàÊàêÁöÑÊñáÊú¨
        voice: Â£∞Èü≥Á±ªÂûã
        output_path: ËæìÂá∫Ë∑ØÂæÑ
        
    Returns:
        ÁîüÊàêÁöÑÈü≥È¢ëÊñá‰ª∂Ë∑ØÂæÑ
    """
    try:
        config = {'voice': voice}
        adapter = EdgeTTSAdapter(config)
        adapter.initialize()
        adapter.configure(config)
        
        result = adapter.synthesize(text, output_path)
        adapter.cleanup()
        
        return result.audio_path or ""
        
    except Exception as e:
        print(f"‚ùå Edge TTSÂêàÊàêÂ§±Ë¥•: {e}")
        raise 